# -*- coding: utf-8 -*-
"""UAV ASSIG1 DIVYA 250359

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12n8niqUfXjhXvvTWvRArYBMgSVFob73f
"""

import sys
sys.setrecursionlimit(10**7)

def dfs(node, parent):
    visited[node] = True
    for neighbor in adj[node]:
        if not visited[neighbor]:
            if dfs(neighbor, node):
                return True
        elif neighbor != parent:
            # Visited and not parent => cycle
            return True
    return False


# Input
n, m = map(int, input().split())
adj = [[] for _ in range(n + 1)]

for _ in range(m):
    u, v = map(int, input().split())
    adj[u].append(v)
    adj[v].append(u)

visited = [False] * (n + 1)

# Check all components
cycle_found = False
for i in range(1, n + 1):
    if not visited[i]:
        if dfs(i, -1):
            cycle_found = True
            break

# Output
if cycle_found:
    print("YES")
else:
    print("NO")

"""# New Section"""

import sys
sys.setrecursionlimit(10**7)

def dfs(node, parent):
    visited[node] = True
    for neighbor in adj[node]:
        if not visited[neighbor]:
            if dfs(neighbor, node):
                return True
        elif neighbor != parent:
            # Visited and not parent => cycle
            return True
    return False


# Input
n, m = map(int, input().split())
adj = [[] for _ in range(n + 1)]

for _ in range(m):
    u, v = map(int, input().split())
    adj[u].append(v)
    adj[v].append(u)

visited = [False] * (n + 1)

# Check all components
cycle_found = False
for i in range(1, n + 1):
    if not visited[i]:
        if dfs(i, -1):
            cycle_found = True
            break

# Output
if cycle_found:
    print("YES")
else:
    print("NO")

from collections import deque

n, m = map(int, input().split())

adj = [[] for _ in range(n + 1)]
for _ in range(m):
    u, v = map(int, input().split())
    adj[u].append(v)
    adj[v].append(u)

color = [-1] * (n + 1)   # -1 means uncolored

def bfs(start):
    q = deque()
    q.append(start)
    color[start] = 0

    while q:
        node = q.popleft()
        for nei in adj[node]:
            if color[nei] == -1:
                color[nei] = 1 - color[node]
                q.append(nei)
            elif color[nei] == color[node]:
                return False
    return True


is_bipartite = True
for i in range(1, n + 1):
    if color[i] == -1:
        if not bfs(i):
            is_bipartite = False
            break

if is_bipartite:
    print("YES")
    print(*color[1:])
else:
    print("NO")

fromfrom collections import deque
from
n, m = map(int, input().split())

adj = [[] for _ in range(n + 1)]
for _ in range(m):
    u, v = map(int, input().split())
    adj[u].append(v)
    adj[v].append(u)

color = [-1] * (n + 1)   # -1 means uncolored

def bfs(start):
    q = deque()
    q.append(start)
    color[start] = 0

    while q:
        node = q.popleft()
        for nei in adj[node]:
            if color[nei] == -1:
                color[nei] = 1 - color[node]
                q.append(nei)
            elif color[nei] == color[node]:
                return False
    return True


is_bipartite = True
for i in range(1, n + 1):
    if color[i] == -1:
        if not bfs(i):
            is_bipartite = False
            break

if is_bipartite:
    print("YES")
    print(*color[1:])
else:
    print("NO")

import heapq

n, m = map(int, input().split())
adj = [[] for _ in range(n + 1)]

for _ in range(m):
    u, v, w = map(int, input().split())
    adj[u].append((v, w))

INF = 10**18
dist = [INF] * (n + 1)
dist[1] = 0

pq = [(0, 1)]  # (distance, node)

while pq:
    d, u = heapq.heappop(pq)
    if d > dist[u]:
        continue
    for v, w in adj[u]:
        if dist[v] > d + w:
            dist[v] = d + w
            heapq.heappush(pq, (dist[v], v))

print(-1 if dist[n] == INF else dist[n])

import heapq

n, m = map(int, input().split())
adj = [[] for _ in range(n + 1)]

for _ in range(m):
    u, v, w = map(int, input().split())
    adj[u].append((v, w))

INF = 10**18
dist = [INF] * (n + 1)
dist[1] = 0

pq = [(0, 1)]  # (distance, node)

while pq:
    d, u = heapq.heappop(pq)
    if d > dist[u]:
        continue
    for v, w in adj[u]:
        if dist[v] > d + w:
            dist[v] = d + w
            heapq.heappush(pq, (dist[v], v))

print(-1 if dist[n] == INF else dist[n])

import heapq

# Input
n, m, k = map(int, input().split())

adj = [[] for _ in range(n + 1)]
for _ in range(m):
    u, v, w = map(int, input().split())
    adj[u].append((v, w))

waypoints = list(map(int, input().split()))
is_wp = [False] * (n + 1)
for x in waypoints:
    is_wp[x] = True

INF = 10**18
# dist[node][used]
dist = [[INF, INF] for _ in range(n + 1)]
dist[1][0] = 0

pq = [(0, 1, 0)]  # (distance, node, hyperloop_used)

while pq:
    d, u, used = heapq.heappop(pq)
    if d > dist[u][used]:
        continue

    # Normal edges
    for v, w in adj[u]:
        if dist[v][used] > d + w:
            dist[v][used] = d + w
            heapq.heappush(pq, (dist[v][used], v, used))

    # Hyperloop jump (only once)
    if used == 0 and is_wp[u]:
        for v in waypoints:
            if dist[v][1] > d:
                dist[v][1] = d
                heapq.heappush(pq, (d, v, 1))

ans = min(dist[n][0], dist[n][1])
print(-1 if ans == INF else ans)

import heapq

# Input
n, m, k = map(int, input().split())

adj = [[] for _ in range(n + 1)]
for _ in range(m):
    u, v, w = map(int, input().split())
    adj[u].append((v, w))

waypoints = list(map(int, input().split()))
is_wp = [False] * (n + 1)
for x in waypoints:
    is_wp[x] = True

INF = 10**18
# dist[node][used]
dist = [[INF, INF] for _ in range(n + 1)]
dist[1][0] = 0

pq = [(0, 1, 0)]  # (distance, node, hyperloop_used)

while pq:
    d, u, used = heapq.heappop(pq)
    if d > dist[u][used]:
        continue

    # Normal edges
    for v, w in adj[u]:
        if dist[v][used] > d + w:
            dist[v][used] = d + w
            heapq.heappush(pq, (dist[v][used], v, used))

    # Hyperloop jump (only once)
    if used == 0 and is_wp[u]:
        for v in waypoints:
            if dist[v][1] > d:
                dist[v][1] = d
                heapq.heappush(pq, (d, v, 1))

ans = min(dist[n][0], dist[n][1])
print(-1 if ans == INF else ans)