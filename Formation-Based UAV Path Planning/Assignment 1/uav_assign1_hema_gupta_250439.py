# -*- coding: utf-8 -*-
"""UAV ASSIGN1 HEMA_GUPTA_250439

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1c684VJidiewR0shuid12giuvsSzuFzz-

**Problem 1**:

# Cycle Detection Using DFS  
You are given an undirected graph G with n vertices and m edges. A cycle
is a sequence of distinct vertices
v1, v2, . . . , vk (k ≥ 3)
such that each consecutive pair is connected by an edge, and vk is connected
to v1.    

Your task: determine whether the graph contains any cycle.

Input Format

• First line: n, m

• Next m lines: edges u, v (undirected)

Output Format
Print:

• YES if the graph contains a cycle.

• NO otherwise.

Constraints
1 ≤ n, m ≤ 2 × 10^5

Sample Cases

Sample 1:

4 4    

1 2

2 3

3 1

3 4

Sample 2:

5 4

1 2

2 3

3 4

4 5
"""

class Graph:
    def __init__(self, vertices):
        self.V = vertices
        self.graph = [[] for _ in range(vertices)]

    def add_edge(self, u, v):
        if u == v:   # self-loop
            self.has_self_loop = True
        self.graph[u].append(v)
        self.graph[v].append(u)

    def dfs_cycle(self, v, visited, parent):
        visited[v] = True

        for neighbor in self.graph[v]:
            if not visited[neighbor]:
                if self.dfs_cycle(neighbor, visited, v):
                    return True
            elif neighbor != parent:
                return True

        return False

    def has_cycle(self):
        visited = [False] * self.V

        for v in range(self.V):
            if not visited[v]:
                if self.dfs_cycle(v, visited, -1):
                    return True
        return False


n, m = map(int, input().split())
g = Graph(n)

for _ in range(m):
    u, v = map(int, input().split())
    g.add_edge(u - 1, v - 1)

print("YES" if g.has_cycle() else "NO")

"""SAMPLE CASES

1.YES
2.NO

ADDITIONAL TEST CASE

1.YES
2.NO
3.YES
4.NO
5.NO

**Problem 2**:

# Bipartite Graph Check Using BFS

You are given an undirected graph G with n vertices and m edges. Your
task is to determine if the graph is bipartite, meaning it can be colored with
colors {0, 1} such that adjacent vertices have different colors.

Input Format

• n,m

• m edges u, v

Output Format

• Print YES if the graph is bipartite.

• Otherwise print NO.

• If bipartite, also print coloring c1, c2, . . . , cn.
"""

class Graph:
    def __init__(self, vertices):
        self.V = vertices
        self.graph = [[] for _ in range(vertices)]

    def add_edge(self, u, v):
        if u == v:   # self-loop
            self.has_self_loop = True
        self.graph[u].append(v)
        self.graph[v].append(u)

"""SAMPLE CASE

1.YES 0 1 0

2.NO

TEST CASE

1.YES 0 1 0 1

2 YES 0 1 0 1 0

3.YES 0 1 0 1

4.NO

5.YES 0

**Problem 3:**

# Shortest Path Using Dijkstra’s Algorithm

You are given a directed weighted graph with n vertices and m edges. Each
edge (u, v) has a positive weight w.

Your task: compute the shortest distance from node 1 to node n.

Input Format

• n, m

• Each of the m lines: u, v, w

Output Format

• Print shortest distance from 1 to n

• Print -1 if no path exists
"""

import heapq

def dijkstra(n, edges):
    adj = [[] for _ in range(n + 1)]
    for u, v, w in edges:
        adj[u].append((v, w))

    INF = float('inf')
    dist = [INF] * (n + 1)
    dist[1] = 0

    pq = [(0, 1)]

    while pq:
        cur_dist, u = heapq.heappop(pq)

        if cur_dist > dist[u]:
            continue

        for v, w in adj[u]:
            if dist[u] + w < dist[v]:
                dist[v] = dist[u] + w
                heapq.heappush(pq, (dist[v], v))

    return -1 if dist[n] == INF else dist[n]


# -------- Input / Output --------
n, m = map(int, input().split())
edges = [tuple(map(int, input().split())) for _ in range(m)]

print(dijkstra(n, edges))

"""**Problem 4**:

# Shortest Path With a Single Hyperloop Jump Between Waypoints

You are given a directed weighted graph with n vertices and m edges. Each
edge (u, v) has a positive weight w.

Additionally, you are given k special vertices called waypoints. You may
use the Hyperloop to instantly travel between any two waypoints at zero
cost, but the Hyperloop may be used at most once in the entire journey.
Your task is to compute the shortest distance from vertex 1 to vertex n,
assuming you may choose to use the Hyperloop once or not at all.

Input Format

• First line: integers n, m, k.

• Next m lines: u, v, w describing directed edges with weight w.

• Final line: k integers x1, x2, . . . , xk representing waypoint nodes.

Output Format

• Print the shortest distance from 1 to n.

• If no valid route exists, print -1.

Rules

• You may travel normally along weighted edges.

• You may optionally use one Hyperloop jump: choose any two waypoint
vertices and move between them at cost 0.

• You may not use the Hyperloop more than once.

"""