# -*- coding: utf-8 -*-
"""UAV_ASSIG2_HEMA GUPTA_250439

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12V-JV2x3gDeVqSq9KGXikb-sKoMpXsrY

**PROBLEM STATEMENT**
You are given a two-dimensional square grid of size 200 × 200. Each cell represents a traversable
location unless marked as an obstacle.
• Start cell: (0, 0)
• Goal cell: (200, 200)
Movement is allowed in eight directions:
• Horizontal and vertical moves have cost 1.
• Diagonal moves have cost √2.

Obstacle Configuration

The following square obstacles block traversal:

• (40, 40) to (70, 70)
• (90, 120) to (130, 160)
• (150, 50) to (180, 90)
• (60, 150) to (100, 190)

**TASKS**
1. Represent the grid as a graph using the 8-direction movement model.
2. Dijkstra’s Algorithm
• Find the shortest path from the start to the goal.
• Report the total path cost.
• Report the number of expanded nodes.
3. A* Algorithm
• Design your own heuristic function.
• Use it to find the shortest path from the start to the goal.
• Report the total path cost.
• Report the number of expanded nodes.
• Briefly comment (1–2 sentences) on whether you believe your heuristic does not overestimate
the true remaining cost.
4. Compare Dijkstra’s algorithm and A* in terms of:
• Path length
• Number of expanded nodes
• Overall efficiency
"""

import matplotlib.pyplot as plt
import math

N = 201


obstacles = [
    (40, 40, 70, 70),
    (90, 120, 130, 160),
    (150, 50, 180, 90),
    (60, 150, 100, 190)
]


blocked = [[False]*N for _ in range(N)]
for x1, y1, x2, y2 in obstacles:
    for x in range(x1, x2+1):
        for y in range(y1, y2+1):
            blocked[x][y] = True


directions = []
for dx in [-1,0,1]:
    for dy in [-1,0,1]:
        if dx == 0 and dy == 0:
            continue
        directions.append((dx, dy))


fig, ax = plt.subplots(figsize=(8,8))
ax.set_xlim(0, N)
ax.set_ylim(0, N)
ax.set_aspect('equal')
ax.set_xticks([])
ax.set_yticks([])


for x in range(0, N, 5):
    for y in range(0, N, 5):
        if not blocked[x][y]:
            ax.plot(x+0.5, y+0.5, 'ko', markersize=1)


for x1, y1, x2, y2 in obstacles:
    rect = plt.Rectangle((x1, y1), x2-x1+1, y2-y1+1, color='red', alpha=0.5)
    ax.add_patch(rect)


ax.plot(0.5, 0.5, 'go', markersize=8, label='Start')
ax.plot(200.5, 200.5, 'bo', markersize=8, label='Goal')


for x in range(0, N, 20):
    for y in range(0, N, 20):
        if blocked[x][y]:
            continue
        for dx, dy in directions:
            nx, ny = x+dx, y+dy
            if 0 <= nx < N and 0 <= ny < N and not blocked[nx][ny]:
                ax.plot([x+0.5, nx+0.5], [y+0.5, ny+0.5], 'gray', linewidth=0.5, alpha=0.3)

plt.title("201×201 Grid Graph with Obstacles, Start, and Goal")
plt.legend()
plt.show()

import heapq
import math

N = 201
start = (0, 0)
goal = (200, 200)


obstacles = [
    (40, 40, 70, 70),
    (90, 120, 130, 160),
    (150, 50, 180, 90),
    (60, 150, 100, 190)
]


blocked = [[False]*N for _ in range(N)]
for x1, y1, x2, y2 in obstacles:
    for x in range(x1, x2 + 1):
        for y in range(y1, y2 + 1):
            blocked[x][y] = True


directions = []
for dx in [-1, 0, 1]:
    for dy in [-1, 0, 1]:
        if dx == 0 and dy == 0:
            continue
        cost = math.sqrt(2) if abs(dx) == 1 and abs(dy) == 1 else 1
        directions.append((dx, dy, cost))

INF = float("inf")
dist = [[INF]*N for _ in range(N)]
visited = [[False]*N for _ in range(N)]

pq = []
dist[0][0] = 0
heapq.heappush(pq, (0, 0, 0))

expanded_nodes = 0

while pq:
    d, x, y = heapq.heappop(pq)
    if visited[x][y]:
        continue

    visited[x][y] = True
    expanded_nodes += 1

    if (x, y) == goal:
        break

    for dx, dy, cost in directions:
        nx, ny = x + dx, y + dy
        if 0 <= nx < N and 0 <= ny < N and not blocked[nx][ny]:
            nd = d + cost
            if nd < dist[nx][ny]:
                dist[nx][ny] = nd
                heapq.heappush(pq, (nd, nx, ny))

print("Shortest path cost:", dist[200][200])
print("Expanded nodes:", expanded_nodes)

import heapq
import math

N = 201
start = (0, 0)
goal = (200, 200)


obstacles = [
    (40, 40, 70, 70),
    (90, 120, 130, 160),
    (150, 50, 180, 90),
    (60, 150, 100, 190)
]


blocked = [[False]*N for _ in range(N)]
for x1, y1, x2, y2 in obstacles:
    for x in range(x1, x2 + 1):
        for y in range(y1, y2 + 1):
            blocked[x][y] = True


directions = []
for dx in [-1, 0, 1]:
    for dy in [-1, 0, 1]:
        if dx == 0 and dy == 0:
            continue
        cost = math.sqrt(2) if abs(dx) == 1 and abs(dy) == 1 else 1
        directions.append((dx, dy, cost))


def heuristic(x, y):
    dx = abs(x - goal[0])
    dy = abs(y - goal[1])
    return (max(dx, dy) - min(dx, dy)) + min(dx, dy) * math.sqrt(2)

INF = float("inf")
g_cost = [[INF]*N for _ in range(N)]
visited = [[False]*N for _ in range(N)]

pq = []
g_cost[0][0] = 0
heapq.heappush(pq, (heuristic(0,0), 0, 0, 0))

expanded_nodes = 0

while pq:
    f, g, x, y = heapq.heappop(pq)

    if visited[x][y]:
        continue

    visited[x][y] = True
    expanded_nodes += 1

    if (x, y) == goal:
        break

    for dx, dy, cost in directions:
        nx, ny = x + dx, y + dy
        if 0 <= nx < N and 0 <= ny < N and not blocked[nx][ny]:
            ng = g + cost
            if ng < g_cost[nx][ny]:
                g_cost[nx][ny] = ng
                nf = ng + heuristic(nx, ny)
                heapq.heappush(pq, (nf, ng, nx, ny))

print("A* shortest path cost:", g_cost[200][200])
print("Expanded nodes:", expanded_nodes)

"""**COMPARISON**

PATH LENGTH:- Path length is same in both the cases.

No. of expanded nodes:- A* use less nodes in comparison of Dijkstra's algorithm.

Overall:- A* is more efficient than Dijkstra's algorithm.

"""